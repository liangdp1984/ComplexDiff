#' @title Scaling Factor Estimates Based on Kernal Density Bump Hunting
#' 
#' @description This function iteratively invokes \code{complexNormPair}
#' for scaling factor estimates across multiple samples, i.e. replicates
#' and conditions.
#' 
#' @param count A matrix of read counts for peaks or
#' high coverage bins, where columns are samples and rows are peaks
#' or bins. This matrix can be generated by function \code{regionCounts}.
#' @param cutoff See function \code{complexNormPair}. (Default: 50)
#' @param fold See function \code{complexNormPair}. (Default: 10)
#' @param h See function \code{complexNormPair}. (Default: 0.1)
#' @param plot See function \code{complexNormPair}. (Default: FALSE)
#' @param sanity A logical indicator if checking sanity across replicates
#' in the same conditions. A negative report of sanity check indicates
#' either a bad experiment or a bad initiation of function parameters.
#' (Default: FALSE)
#' @param samfac \code{NULL} or a two-level factor specifying biological
#' conditions for samples in \code{count} (e.g. control
#' & treatment). This parameter is only appliable when \code{sanity} is
#' TRUE. (Default: NULL)
#'
#' @return
#' A numeric vector indicating estimated size of samples.
#'
#' @export
#' 
#' @examples
#' ## load sample data
#' data(complex)
#' names(complex)
#' 
#' ## test sample data
#' complexNorm(complex$counts)
#' complexNorm(complex$counts,sanity=TRUE,samfac=factor(c("ctr","tre")))

complexNorm <- function(count, cutoff=50L, fold=10, h=0.1, plot=FALSE,
                        sanity=FALSE, samfac=NULL){
    stopifnot(is.matrix(count) && ncol(count) >= 2)
    stopifnot(is.numeric(cutoff) && length(cutoff) == 1 && cutoff >= 0)
    stopifnot(is.numeric(fold) && length(fold) == 1 && fold > 1)
    stopifnot(is.numeric(h) && length(h) == 1 && h > 0)
    stopifnot(is.logical(plot) && length(plot) == 1)
    stopifnot(is.logical(sanity) && length(sanity) == 1)
    if(sanity){
        stopifnot(is.factor(samfac) && nlevels(samfac) == 2 &&
                  ncol(count) == length(samfac))        
    }
    sizefac <- 1
    cmplxtype <- 'unimodel'
    for(i in seq_len(ncol(count))[-1]){
        normpair <- complexNormPair(count[,c(1,i)], cutoff=cutoff,
                                    fold=fold, h=h, plot=plot)
        sizefac <- c(sizefac,normpair$sizefac[2])
        cmplxtype <- c(cmplxtype,normpair$type)
    }
    if(sanity){
        sanind <- all(sapply(levels(samfac),function(x)
                   length(unique(cmplxtype[samfac==x]))==1))
        if(sanind) cat("Sanity check passed...\n")
        else cat("Sanity check failed...\n")
    }
    sizefac <- sizefac / median(sizefac)
    sizefac
}
