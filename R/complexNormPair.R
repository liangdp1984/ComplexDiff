#' @title Scaling Factor Estimate Between Two Samples
#' 
#' @description This function determines the binding type of given
#' ChIP-Seq samples first by kernal density bump hunting.
#' If bimodel, it further calculate  which
#' mode to be used for scaling. Then, it provides scaling factors
#' for normalization. This function serves as the basis for function
#' \code{complexNorm}, which iteratively invokes this function for
#' scaling factor estimates across replicates and conditions.
#' 
#' @param count A two-column matrix of read counts for peaks or
#' high coverage bins, where columns are samples and rows are peaks
#' or bins. This matrix can be generated by function \code{regionCounts}.
#' @param cutoff A numeric cut off on \code{count} matrix. If positive,
#' only peaks/bins with counts larger than \code{cutoff} in at least one
#' sample are used to estimate the scaling factor. We recommend a larger
#' cutoff since background signal can dramatically mask the right estimation
#' of kernal density, especially for deep sequenced ChIP-seq samples.
#' (Default: 50)
#' @param fold A numeric threshold to help determining the binding type.
#' In detail, if top 2 estimated modes on smoothed kernal density have
#' a height differece less than the folds given by \code{fold}, binding
#' type will be determined as bimodel; otherwise, it is unimodel. This
#' number should be larger than 1. (Default: 10)
#' @param h Initial smoothing factor when estimating kernal density for bump
#' hunting. (Default: 0.1)
#' @param plot A logical indicator that if MA plot and smoothed kernal density
#' should be visualized. (Default: FALSE)
#'
#' @import matrixStats
#'
#' @return
#' A list with the following conponents:
#' \item{sizefac}{A numeric vector indicating estimated size of the
#' given two samples}
#' \item{type}{A character with value either "bimodel" or "unimodel",
#' indicating the binding types}
#'
#' @export
#' 
#' @examples
#' 

complexNormPair <- function(count, cutoff=50L, fold=10, h=0.1, plot=FALSE){
    stopifnot(is.matrix(count) && ncol(count) == 2)
    stopifnot(is.numeric(cutoff) && length(cutoff) == 1 && cutoff >= 0)
    stopifnot(is.numeric(fold) && length(fold) == 1 && fold > 1)
    stopifnot(is.numeric(h) && length(h) == 1 && h > 0)
    stopifnot(is.logical(plot) && length(plot) == 1)
    ## raw M & A
    counttmp <- count[rowMaxs(count) >= cutoff,]
    logcount <- log2(counttmp + 0.5)
    M <- rowDiffs(logcount)
    A <- rowMeans(logcount)
    ## kernal density bumps
    bump <- c()
    ix <- seq(round(min(M), 1), max(M), 0.05)
    while(length(bump)<2){
        dm <- rowMeans(sapply(M, function(m) dnorm(ix, mean=m, sd=h)))
        bump <- which(diff(sign(diff(dm))) == -2) + 1
        bump2 <- bump[order(dm[bump],
                            decreasing=TRUE)[seq_len(
                                min(2,length(bump)))]]
        mu <- ix[bump2]
        mudm <- dm[bump2]
        h <- h * 0.8
    }
    ## protein complex type
    enrich <- abs(log(mudm[1] / mudm[2]))
    if(enrich <= log(fold)){
        cmplxtype <- "bimodel"
    }else{
        cmplxtype <- "unimodel"
    }
    ## size factors
    M0idx <- 1
    if(cmplxtype == "bimodel"){
        Mtmp <- M[A > max(A) * 0.8]
        ind <- vector('integer',length=length(Mtmp))
        ind[abs(Mtmp-mu[1]) <= abs(Mtmp-mu[2])] <- 1L
        if(sum(ind) < length(ind)/2){
            M0idx <- 2
        }
    }
    M0 <- mu[M0idx]
    sizefac <- c(1,2^M0)
    ## plots
    if(plot){
        layout(matrix(1:2,1,2))
        plot(A,M,pch=20,cex=0.5,main=cmplxtype)
        abline(h=0,lty=2,col='red',lwd=2)
        plot(density(M,na.rm = T,adjust=1),xlab='M',main=cmplxtype,lwd=2)
        if(cmplxtype == "bimodel")
            abline(v=mu,lty=2,col='blue',lwd=2)
        else abline(v=M0,lwd=2,col='blue',lty=2)
    }
    list(sizefac=sizefac,type=cmplxtype)
}
