#' @title Estimate Size Factors of Samples
#'
#' @description This function estimates sample size factors for normalization
#' purpose in downsteam analysis. Size factors of sample pairs are
#' estimated firstly by comparing samples to the same sample (*i.e.* the
#' sample corresponding to first column of count matrix). Then, size factors
#' are combined across all samples with the median size factor as 1.
#' In detail, binding type is first estimated using the same strategy as
#' function \code{chipType} for each sample pairs. When biomodel, size factor
#' is calcualted based on a decision on which kernale density mode to be used
#' for scaling.
#'
#' @param count A matrix of read counts for peaks or
#' high coverage bins, where columns are samples and rows are peaks
#' or bins. This matrix can be generated by function \code{regionReads}.
#' @param cutoff A numeric cut off on \code{count} matrix. If positive,
#' only peaks/bins with counts larger than \code{cutoff} in at least one
#' sample are used to estimate the scaling factor. We recommend a larger
#' cutoff since background signal can dramatically mask the right estimation
#' of kernal density, especially for deep sequenced ChIP-seq samples.
#' (Default: 50)
#' @param fold A numeric threshold to help determining the binding type.
#' In detail, if top 2 estimated modes on smoothed kernal density have
#' a height differece less than the folds given by \code{fold}, binding
#' type will be determined as bimodel; otherwise, it is unimodel. This
#' number should be larger than 1. (Default: 10)
#' @param h Initial smoothing factor when estimating kernal density for
#' bump hunting. (Default: 0.1)
#' @param plot A logical indicator that if M-A plot and smoothed kernal
#' density should be visualized. (Default: FALSE)
#' @param sanity A logical indicator if checking sanity across replicates
#' in the same conditions. A negative report of sanity check indicates
#' either a bad experiment (*e.g.* binding type is not consistent across
#' replicates) or a bad initiation of function parameters (*e.g.*
#' \code{cutoff} and \code{fold} are not pre-estimated well). However,
#' a negative report of sanity check doesn't neccessarily mean a bad
#' estimation of size factors, as the strategy of hunting kernal density
#' mode can mostly find the right scaling regardless of unimodel or
#' bimodel. (Default: FALSE)
#' @param samfac \code{NULL} or a two-level factor specifying biological
#' conditions for samples in \code{count} (e.g. control
#' & treatment). This parameter is only appliable when \code{sanity} is
#' TRUE. (Default: NULL)
#'
#' @importFrom matrixStats rowMaxs
#' @importFrom matrixStats rowDiffs
#'
#' @return
#' A list with the following conponents:
#' \item{sizefac}{A numeric vector indicating estimated size factors
#' of samples}
#' \item{type}{A character vector with value either "bimodel" or "unimodel",
#' indicating the binding types by comparing ro the sample "control"}
#'
#' @export
#'
#' @examples
#' ## load sample data
#' data(complex)
#' names(complex)
#'
#' ## test sample data
#' sizeFac(complex$counts)

sizeFac <- function(count, cutoff=50L, fold=10, h=0.1, plot=FALSE,
                            sanity=FALSE, samfac=NULL){
    stopifnot(is.matrix(count) && ncol(count) >= 2)
    stopifnot(is.numeric(cutoff) && length(cutoff) == 1 && cutoff >= 0)
    stopifnot(is.numeric(fold) && length(fold) == 1 && fold > 1)
    stopifnot(is.numeric(h) && length(h) == 1 && h > 0)
    stopifnot(is.logical(plot) && length(plot) == 1)
    stopifnot(is.logical(sanity) && length(sanity) == 1)
    if(sanity){
        stopifnot(is.factor(samfac) && nlevels(samfac) == 2 &&
                  ncol(count) == length(samfac))
    }
    ## loop on each sample pair
    sizefacs <- 1
    cmplxtypes <- 'unimodel'
    for(i in seq_len(ncol(count))[-1]){
        countpair <- count[,c(1,i)]
        ## raw M & A
        counttmp <- countpair[rowMaxs(countpair) >= cutoff,]
        logcount <- log2(counttmp + 0.5)
        M <- rowDiffs(logcount)
        A <- rowMeans(logcount)
        ## kernal density bumps
        bump <- c()
        hpair <- h
        ix <- seq(round(min(M), 1), max(M), 0.05)
        while(length(bump)<2){
            dm <- rowMeans(sapply(M, function(m) dnorm(ix, mean=m, sd=hpair)))
            bump <- which(diff(sign(diff(dm))) == -2) + 1
            bump2 <- bump[order(dm[bump],
                                decreasing=TRUE)[seq_len(
                                min(2,length(bump)))]]
            mu <- ix[bump2]
            mudm <- dm[bump2]
            hpair <- hpair * 0.8
        }
        ## chip type
        enrich <- abs(log(mudm[1] / mudm[2]))
        if(enrich <= log(fold)){
            cmplxtype <- "bimodel"
        }else{
            cmplxtype <- "unimodel"
        }
        ## size factor
        M0idx <- 1
        if(cmplxtype == "bimodel"){
            Mtmp <- M[A > max(A) * 0.8]
            ind <- vector('integer',length=length(Mtmp))
            ind[abs(Mtmp-mu[1]) <= abs(Mtmp-mu[2])] <- 1L
            if(sum(ind) < length(ind)/2){
                M0idx <- 2
            }
        }
        M0 <- mu[M0idx]
        sizefac <- c(1,2^M0)
        ## plots
        if(plot){
            layout(matrix(1:2,1,2))
            plot(A,M,pch=20,cex=0.5,main=cmplxtype)
            abline(h=0,lty=2,col='red',lwd=2)
            plot(density(M,na.rm = T,adjust=1),xlab='M',main=cmplxtype,lwd=2)
            if(cmplxtype == "bimodel")
                abline(v=mu,lty=2,col='blue',lwd=2)
            else abline(v=M0,lwd=2,col='blue',lty=2)
        }
        sizefacs <- c(sizefacs,sizefac[2])
        cmplxtypes <- c(cmplxtypes,cmplxtype)
    }
    ## sanity check
    if(sanity){
        sanind <- all(sapply(levels(samfac),function(x)
                   length(unique(cmplxtypes[samfac==x]))==1))
        if(sanind) cat("Sanity check passed...\n")
        else cat("Sanity check failed...\n")
    }
    sizefacs <- sizefacs / median(sizefacs)
    cmplxtypes[1] <- "control"
    list(sizefac=sizefacs,type=cmplxtypes)
}
