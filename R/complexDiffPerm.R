#' @title Differential Binding Estimation with Permutation
#' 
#' @description
#' This function does differential binding estimation and additional
#' permutation analysis. For differential binding estimation, see
#' function \code{complexDiff}. Permutation analysis is obtained by
#' shuffling samples between compared conditions. Customized shuffling
#' can also be specified by parameter \code{permute} for complicated
#' experiment designs.
#' 
#' 
#' @param count A matrix of read counts for genome-wide bins,
#' where columns correspond to samples and rows correspond to bins.
#' This matrix can be generated by function \code{regionCounts}.
#' @param bins A GRanges object recording bins corresponding to
#' rows of \code{count} matrix.
#' This object can be generated by function \code{regionCounts}.
#' @param meta A DataFrame object recording sample annotations.
#' Rows of \code{meta} correspond to columns of \code{count}.
#' @param design A formula object which expresses how the counts for
#' each bin depend on the variables in \code{meta}, e.g. '~ group +
#' condition' etc. By default, the last variable in the formula
#' will be used to build the differential binding contrast. At most
#' two variables are allowed if \code{diffmeth} is set to 'ttest'.
#' (Details see below)
#' @param sizefac A numeric vector indicating estimated size of samples
#' for normalization purpose. This vector can be generated by
#' function \code{complexNorm}.
#' @param rccut A numeric cutoff on normalized \code{count} matrix by
#' \code{sizefac}. If positive, only bins with normalized counts larger than
#' \code{rccut} in at least one sample are selected for fold change estimate.
#' Unlike other functions in this package, moderate cutoff would be better
#' as too large results more false negative and too small increases the
#' time cost. (Default: 15)
#' @param fccut A numeric cutoff on bins' smoothed log2foldchanges for bump
#' hunting. Neighbor bins with fold change larger than this value will be
#' merged together with allowed gaps. (Default: 0.4)
#' @param gap A integer specifying the gaps allowed for bin merging, in the
#' unit of number of bins. (Default: 2)
#' @param permute A matrix where each row contains shuffled indices of
#' samples. If \code{NULL}, permutation is automatically obtained by shuffling
#' samples between compared conditions. This object can be generated by using
#' R package \code{permute} as well.
#' @param maxperm Maximum number of permutations to be finished. (Default:10)
#' @param diffmeth Method for statistical testing of differential binding.
#' (Default: 'DESeq2')
#'
#' @details
#' If 'ttest' is selected, ... 
#' 
#' @import GenomicRanges
#' 
#' @return
#' A list with the following components:
#' \item{region}{A GRanges object containing potential regions with
#' differential binding}
#' \item{diff}{A DataFrame containing estimated significance of
#' potential differential binding regions, including tested statistic,
#' log2 fold change, p-value and permutation p-value}
#'
#' @export
#' 


complexDiffPerm <- function(count, bins, meta, design, sizefac,
                            rccut=15, fccut=0.4, gap=2,
                            permute=NULL, maxperm=10,
                            diffmeth=c("DESeq2","limma","ttest")){
    stopifnot(is.matrix(count) && ncol(count) >= 2)
    stopifnot(class(bins) == "GRanges" && length(bins) == nrow(count))
    stopifnot(is.data.frame(meta) && ncol(meta)>=1)
    stopifnot(class(design) == "formula")
    effects <- model.frame(design, data = meta)
    stopifnot(ncol(effects) >= 1 && length(unique(effects[,ncol(effects)]))==2)
    stopifnot(is.numeric(sizefac) && length(sizefac) == ncol(count)
              && all(sizefac > 0))
    stopifnot(is.numeric(rccut) && length(rccut) == 1 && rccut >= 0)
    stopifnot(is.numeric(fccut) && length(fccut) == 1 && fccut > 0)
    stopifnot(is.numeric(gap) && length(gap) == 1 && gap >= 0)
    stopifnot(is.null(permute) ||
              (is.matrix(permute) &&
               all(apply(permute,1,function(x)
                         identical(seq_len(ncol(count)),sort(x))))))
    stopifnot(is.numeric(maxperm) && length(maxperm) == 1 && maxperm >= 1)
    diffmeth <- match.arg(diffmeth)
    if(diffmeth=="ttest"){
        paired <- FALSE
        if(ncol(effects) > 2 || (ncol(effects) == 2 &&
           any(sapply(split(effects[,2],effects[,1]),function(x)
                      length(x) !=2 || length(unique(x)) != 2)))){
            cat("try methods other than 'ttest' for a complex design.\n
                 differential analysis abandoned.\n")
            return(0)
        }else if(ncol(effects) == 2){
            paired <- TRUE
        }
    }
    ## real test
    real <- complexDiff(count=count, bins=bins, meta=meta, design=design,
                        sizefac=sizefac,rccut=rccut, fccut=fccut, gap=gap,
                        diffmeth=diffmeth)
    cat("Differential analysis of real data......done!\n")
    ## permute test
    if(is.null(permute)){
        level <- effects[,ncol(effects)]
        subn <- min(floor(table(level)/2))
        combs <- combn(min(table(level)),subn)
        comb1 <- matrix(which(level==(unique(level)[1]))[combs],nrow(combs))
        comb2 <- matrix(which(level==(unique(level)[2]))[combs],nrow(combs))
        comb1 <- comb1[,rep(seq_len(ncol(comb1)),ncol(comb2))]
        comb2 <- comb2[,rep(seq_len(ncol(comb2)),each=ncol(comb1))]
        permute <- t(sapply(seq_len(ncol(comb1)),function(i){
            ranks <- seq_len(ncol(count))
            tmpidx <- match(c(comb1[,i],comb2[,i]),ranks)
            ranks[tmpidx] <- c(comb2[,i],comb1[,i])
            ranks
        }))
    }
    if(maxperm<nrow(permute))
        permute <- permute[sample(seq_len(nrow(permute)),maxperm),]
    n <- nrow(permute)
    cat("Differential analysis of permute data...... Total",n,"times!\n")
    perm <- list()
    for(i in seq_len(n)){
        counttmp <- count[,permute[i,]]
        sizefactmp <- sizefac[permute[i,]]
        perm[[i]] <- complexDiff(count=counttmp, bins=bins, meta=meta,
                                 design=design, sizefac=sizefactmp,
                                 rccut=rccut, fccut=fccut, gap=gap,
                                 diffmeth=diffmeth)
        cat(i,"permute done!\n")
    }
    ## significance evaluation
    permstat <- abs(unlist(sapply(perm,function(x) x$diff$stat)))
    realstat <- abs(real$diff$stat)
    permpv <- sapply(realstat,function(x) sum(x>=permstat))
    real$diff <- data.frame(real$diff,permpv)
    return(real)
}
