#' @title Region Read Counts from ChIP-Seq
#' 
#' @description Regions are normally ChIP-Seq peaks. If no peaks provided,
#' this function will generate bin-level counts based on genome information
#' embedded in bam or bigwig files. If bam files provided, counts will be
#' generated by function in Rsubread package; if bigwig files provided,
#' counts will be generated by function in rtracklayer package.
#'
#' @param samples A vector of paths to ChIP-seq files in BAM or Bigwig
#' format.
#' @param peaks GRanges or \code{NULL}. If \code{NULL}, genome-wide
#' high coverage bins with length \code{binsize} will be pre-selected as
#' potential peaks; otherwise, ChIP-seq peaks should be provided as a
#' GRanges object, e.g. a union of peaks identified by peak caller
#' from all samples. (Default: NULL)
#' @param binsize A number specify the bin size. This parameter is
#' only appliable when \code{peaks=NULL}. (Default: 300)
#' @param bincut A numeric cut off on read counts to nominate bins as
#' high coverage candidates. This parameter is only appliable when
#' \code{peaks=NULL}. (Default: 0)
#' @param readlen Sample fragment length with which bigwig files created.
#' This parameter is only appliable when \code{samples} are bigwig files.
#' If \code{NULL}, it is better to multiply \code{bincut} by a scale
#' factor (normally fragment length). (Default: NULL)
#' @param read2pos Parameter of function \code{featureCounts} in package
#' Rsubread. This parameter is only appliable when
#' \code{samples} are bam files. (Default: '5')
#' @param ignoreDup Parameter of function \code{featureCounts} in package
#' Rsubread. This parameter is only appliable when
#' \code{samples} are bam files. (Default: TRUE)
#'
#' @importFrom matrixStats rowMaxs
#' @import IRanges
#' @import GenomeInfoDb
#' @import GenomicRanges
#' @import Rsamtools
#' @import rtracklayer
#' @import Rsubread
#'
#' @return
#' A list with the following components:
#' \item{count}{A data matrix containing read counts for each region in
#' each sample}
#' \item{regions}{A GRanges object recording regions of each row in the
#' count matrix}
#' 
#' @export
#' 
#' @examples
#' library(GenomicRanges)
#' bams <- c(system.file("extdata", "control.bam", package="ComplexDiff"),
#'           system.file("extdata", "treated.bam", package="ComplexDiff"))
#' bins <- GRanges("chr1",IRanges(start = seq(1000000,2000000,300),
#'                       end = seq(1000000,2000000,300)+300-1))
#' rc <- regionCounts(bams,peaks=bins)
#' names(rc)
#' 

regionCounts <- function(samples, peaks=NULL, binsize=300L, bincut=0L,
                       readlen=NULL, read2pos='5', ignoreDup=TRUE){
    stopifnot(is.character(samples))
    stopifnot(is.null(peaks) || class(peaks)=="GRanges")
    stopifnot(is.numeric(binsize) && length(binsize) == 1 &&
              is.numeric(bincut) && length(bincut) == 1)
    stopifnot(is.null(readlen) || (is.numeric(readlen) &&
                                   length(readlen) == 1))
    
    binsize <- round(binsize)
    ## bam or bw
    filext <- sapply(strsplit(basename(samples),"\\."),function(x) rev(x)[1])
    isbam <- all(toupper(filext) %in% "BAM")
    isbw <- all(toupper(filext) %in% c("BW","BIGWIG"))
    if(isbam){
        seqs <- sortSeqlevels(seqinfo(BamFileList(samples)))
    }else if(isbw){
        seqs <- sortSeqlevels(seqinfo(BigWigFile(samples[1])))
    }else{
        stop("sample files must have file extension as bam, bw or BigWig")
    }
    seqs <- seqlengths(seqs)[!grepl("_", seqnames(seqs))]
    ## peaks or windows
    if(is.null(peaks)) {
        starts <- lapply(seqs, function(i) seq(1, i, binsize))
        ends <- lapply(seqs, function(i) {
            if(i%%binsize == 0) seq(binsize, i, binsize)
            else c(seq(binsize, i, binsize), i)
        })
        chrs <- rep(names(seqs), times=sapply(starts, length))
        regions <- GRanges(chrs, IRanges(start=unlist(starts),
                                         end=unlist(ends)))
        seqlengths(regions) <- seqs[seqlevels(regions)]
    }else{
        regions <- sortSeqlevels(peaks)
        seqlevels(regions, force=TRUE) <- names(seqs)
        seqlengths(regions) <- seqs[seqlevels(regions)]
    }
    ## read counts
    if(isbam){
        ## bam files
        anno <- data.frame(GeneID=seq_len(length(regions)),
                           Chr=seqnames(regions), Start=start(regions),
                           End=end(regions), Strand=strand(regions))
        count <- featureCounts(files=samples, annot.ext=anno,
                               read2pos=read2pos, ignoreDup=ignoreDup
				)$counts
    }else{
        ## bigwig files
        count <- c()
        for(i in seq_len(length(samples))){
            meancov <- unlist(summary(BigWigFile(samples[i]),
                                      regions,size=1,type="mean"))
            if(is.null(readlen)){
                count <- cbind(count, round(mcols(meancov)$score *
                                            width(meancov)))
            }else{
                count <- cbind(count, round(mcols(meancov)$score *
                                            width(meancov) / readlen))
            }
        }
    }
    ## filter on windows
    if(is.null(peaks) & bincut > 0){
        binidx <- rowMaxs(count, na.rm=TRUE) >= bincut
        count <- count[binidx, ]
        regions <- regions[binidx]
    }
    list(count=count, regions=regions)
}
